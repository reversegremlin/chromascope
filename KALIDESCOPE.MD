This PRD focuses on **"The Kaleidoscope Test"**—a visual proof-of-concept designed to validate that our pipeline isn't just "detecting volume," but actually understanding the *character* of the music.

We will use **Pygame** for the rendering engine because it allows for high-speed prototyping and real-time feedback, though the logic can be ported to Blender or Manim later.

---

# PRD: The Kaleidoscope Test (Visual Validation)

**Objective:** Create a geometric visualization that maps extracted audio features to specific transformational properties of shapes to verify the "feel" of the data extraction.

---

## 1. The Visual Logic (The "Mapping")

To test the **Audiosyncrasy** pipeline, we will map three distinct data streams to three distinct geometric behaviors:

| Audio Driver | Visual Property | Goal |
| --- | --- | --- |
| **Percussive (Impact)** | **Scale & Thickness** | High-energy transients (drums) should cause the shapes to "kick" or pulse. |
| **Harmonic (Fluidity)** | **Rotation & Orbit** | Smooth melodies should drive the rotation speed and orbital distance of shapes. |
| **Spectral Centroid** | **Complexity (Sides)** | High-pitched sounds increase the number of polygon sides (Triangle  Hexagon  Circle). |
| **Chroma (Pitch)** | **Hue/Color** | The dominant musical note (C, D, E...) maps to the background or shape color. |

---

## 2. Functional Requirements

### 2.1 The "Kaleidoscope" Generator

* **Central Shape:** A regular polygon centered on the screen.
* **Symmetry:** The polygon should be mirrored/duplicated in a radial pattern (6–12 instances) to create a kaleidoscopic effect.
* **Trail Effect:** Implement a slight frame-persistence (motion blur) so high-speed movements leave a visual "echo."

### 2.2 Audio Integration

* The script must load the `manifest.json` generated by the **Audiosyncrasy** pipeline.
* The rendering loop must lock to the `fps` specified in the manifest (e.g., 60 FPS).
* **Smoothing Verification:** The "Polished" data from the pipeline must result in smooth transitions. If a shape "flickers" unpleasantly, the test fails (indicating a need to tune the Attack/Decay in `polisher.py`).

---

## 3. Technical Implementation (Python Stack)

* **Library:** `pygame` (for the window and drawing)
* **Math:** `numpy` (for coordinate rotation and vector math)
* **Color Space:** `colorsys` (to easily map Chroma values to HSV/RGB)

### Geometry Formula (for the Developer)

To render the radial symmetry, the developer should use:



*Where  is driven by harmonic energy and  is an accumulation of harmonic flux.*

---

## 4. Success Criteria (The "Vibe" Check)

1. **Sync:** When the drum hits, the shapes pulse exactly on the frame.
2. **Distinction:** During a vocal or synth solo with no drums, the shapes should move/rotate but *not* pulse.
3. **Color Harmony:** If the song shifts from a dark key (A Minor) to a bright key (C Major), the visual palette shifts noticeably.
4. **Performance:** The test script must render at a stable 60 FPS on standard hardware.

---

## 5. The "Trail" (Logging)

The developer must add a `test_visual.py` to the `/tests` directory.

* **Input:** `tests/assets/click_track.wav`
* **Expected Output:** A window showing a square pulsing perfectly in time with the clicks.

---

